package com.xuwei.serviceproxy.compiler;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.NoType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.xuwei.serviceproxy.compiler.utils.Logger;


/**
 * Created by xuwei.luo on 18/8/31.
 */
//https://github.com/linkedin/dexmaker/blob/master/dexmaker/src/main/java/com/android/dx/stock/ProxyBuilder.java
public final class ClassProxyBuilder {
    public static final String WARNING_TIPS = "DO NOT EDIT THIS FILE!!!";
    private static final String FIELD_NAME_HANDLER = "$__handler";
    private static final String FIELD_NAME_METHODS = "$__methodArray";
    private static final String PROXY_CLASS_NAME_MODEL = "%s_proxy";
    private static final String PROXY_CLASS_PACKAGE = "com.xuwei.serviceproxy";
    private final TypeElement mBaseClass;
    private TypeSpec.Builder mProxyClass;
    private Elements mElements;
    private Logger mLogger;
    private Types mTypes;

    private static final Map<TypeKind, String> PRIMITIVE_TO_BOXED;
    static {
        PRIMITIVE_TO_BOXED = new HashMap<>();
        PRIMITIVE_TO_BOXED.put(TypeKind.BOOLEAN, "Boolean.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.INT, "Integer.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.BYTE, "Byte.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.LONG, "Long.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.SHORT, "Short.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.FLOAT, "Float.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.DOUBLE, "Double.valueOf(%s)");
        PRIMITIVE_TO_BOXED.put(TypeKind.CHAR, "Character.valueOf(%s)");
    }

    /**
     * Wrapper class to let us disambiguate {@link Method} objects.
     * <p>
     * The purpose of this class is to override the {@link #equals(Object)} and {@link #hashCode()}
     * methods so we can use a {@link Set} to remove duplicate methods that are overrides of one
     * another. For these purposes, we consider two methods to be equal if they have the same
     * name, return type, and parameter types.
     */
    private static class MethodSetEntry implements Comparable<MethodSetEntry> {
        private final String name;
        private final ExecutableElement originalMethod;
        private final TypeMirror[] paramTypes;
        private String paramsString;
        private final TypeMirror returnType;

        public MethodSetEntry(ExecutableElement method) {
            this.originalMethod = method;
            this.name = method.getSimpleName().toString();
            List<? extends VariableElement> variableElements = method.getParameters();
            if (variableElements != null && variableElements.size()>0) {
                paramTypes = new TypeMirror[variableElements.size()];
                for (int i=0; i<variableElements.size(); i++) {
                    paramTypes[i] = variableElements.get(i).asType();
                }
            } else {
                paramTypes = new TypeMirror[0];
            }
            this.returnType = method.getReturnType();
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof MethodSetEntry)) {
                return false;
            }
            MethodSetEntry methodSetEntry = (MethodSetEntry) other;
            if (this.name.equals(methodSetEntry.name) && Arrays.equals(this.paramTypes, methodSetEntry.paramTypes)) {
                return true;
            }
            return false;
        }

        @Override
        public int hashCode() {
            int hashCode = (this.name.hashCode() + 527) + 17;
            return hashCode + ((hashCode * 31) + Arrays.hashCode(this.paramTypes));
        }

        private String getParamsString() {
            if (this.paramsString == null) {
                this.paramsString = separateWithCommas(this.paramTypes);
            }
            return this.paramsString;
        }

        @Override
        public int compareTo(MethodSetEntry methodSetEntry) {
            int compareTo = this.name.compareTo(methodSetEntry.name);
            return compareTo != 0 ? compareTo : getParamsString().compareTo(methodSetEntry.getParamsString());
        }

        String separateWithCommas(TypeMirror[] clsArr) {
            int i = 0;
            if (clsArr == null || clsArr.length <= 0) {
                return "";
            }
            if (clsArr.length == 1) {
                return clsArr[0].toString();
            }
            StringBuilder stringBuilder = new StringBuilder();
            while (i < clsArr.length) {
                stringBuilder.append(clsArr[i].toString());
                if (i < clsArr.length - 1) {
                    stringBuilder.append(",");
                }
                i++;
            }
            return stringBuilder.toString();
        }
    }

    private ClassProxyBuilder(TypeElement element, Elements elements, Types types, Logger logger) {
        this.mElements = elements;
        this.mBaseClass = element;
        this.mLogger = logger;
        this.mTypes = types;
    }

    public static ClassProxyBuilder builder(TypeElement cls, Elements elements, Types types, Logger logger) {
        return new ClassProxyBuilder(cls, elements, types, logger);
    }

    public final JavaFile buildProxyClass() {
        ExecutableElement[] methodsToProxyRecursive;

        String generatedName = String.format(PROXY_CLASS_NAME_MODEL, new Object[]{this.mBaseClass.getSimpleName()});
        mProxyClass = TypeSpec.classBuilder(generatedName);
        mProxyClass.addJavadoc(WARNING_TIPS);
        mProxyClass.addModifiers(javax.lang.model.element.Modifier.PUBLIC, javax.lang.model.element.Modifier.FINAL);
        mProxyClass.superclass(convertToTypeName(mBaseClass.asType()));
        generateConstructorsAndFields();
        methodsToProxyRecursive = getMethodsToProxyRecursive();
        generateCodeForAllMethods(methodsToProxyRecursive);
        return JavaFile.builder(PROXY_CLASS_PACKAGE, mProxyClass.build()).build();
    }

    private void generateCodeForAllMethods(ExecutableElement[] methodsToProxy) {
        for (int m = 0; m < methodsToProxy.length; ++m) {

            MethodSpec.Builder proxyMethod = null;
            if (methodsToProxy[m].getModifiers().contains(Modifier.ABSTRACT)) {
                proxyMethod = MethodSpec.methodBuilder(methodsToProxy[m].getSimpleName().toString());
            } else {
                proxyMethod = MethodSpec.methodBuilder(superMethodName(methodsToProxy[m]));
            }

            proxyMethod.addModifiers(Modifier.PUBLIC);
            proxyMethod.returns(convertToTypeName(methodsToProxy[m].getReturnType()));
            List<? extends TypeMirror> thrownTypes = methodsToProxy[m].getThrownTypes();
            if (thrownTypes != null && thrownTypes.size()>0) {
                for (TypeMirror typeMirror : thrownTypes) {
                    proxyMethod.addException(TypeName.get(typeMirror));
                }
            }
            List<? extends VariableElement> paramters = methodsToProxy[m].getParameters();
            if (paramters != null && paramters.size() > 0) {
                for (VariableElement e : paramters) {
                    proxyMethod.addParameter(convertToTypeName(e.asType()), e.getSimpleName().toString());
                }
            }

            if (methodsToProxy[m].getReturnType()!=null &&
                    !(methodsToProxy[m].getReturnType() instanceof NoType)) {
                if (methodsToProxy[m].getModifiers().contains(Modifier.ABSTRACT)) {
                    proxyMethod.addStatement("return ($T) Utils.invoke($L, $L, this, $$__methodArray, this.$$__handler)", convertToTypeName(methodsToProxy[m].getReturnType()), m, getObjectParamStr(methodsToProxy[m].getParameters()));
                } else {
                    proxyMethod.addStatement("return super.$L$L",methodsToProxy[m].getSimpleName().toString(), getParamStr(methodsToProxy[m].getParameters()));
                }
            } else {
                if (methodsToProxy[m].getModifiers().contains(Modifier.ABSTRACT)) {
                    proxyMethod.addStatement("Utils.invoke($L, $L, this, $$__methodArray, this.$$__handler)", m, getObjectParamStr(methodsToProxy[m].getParameters()));
                } else {
                    proxyMethod.addStatement("super.$L$L",methodsToProxy[m].getSimpleName().toString(), getParamStr(methodsToProxy[m].getParameters()));
                }
            }

            mProxyClass.addMethod(proxyMethod.build());
        }
    }

    private TypeName convertToTypeName(TypeMirror typeMirror) {
        return TypeName.get(typeMirror);
    }

    private String getObjectParamStr(List<? extends VariableElement> params) {
        if (params == null || params.size()==0) {
            return "new Object[0]";
        }
        StringBuilder ret = new StringBuilder();
        ret.append("new Object[]{");
        for(int i=0; i<params.size(); i++) {
            ret.append(boxIfRequired(params.get(i)));
            if (i < params.size() - 1) {
                ret.append(",");
            }
        }
        ret.append("}");
        return ret.toString();
    }

    private String getParamStr(List<? extends VariableElement> params) {
        if (params == null || params.size()==0) {
            return "()";
        }

        StringBuilder ret = new StringBuilder();
        ret.append("(");
        for(int i=0; i<params.size(); i++) {
            ret.append(params.get(i));
            if (i < params.size() - 1) {
                ret.append(",");
            }
        }
        ret.append(")");
        return ret.toString();
    }

    private static String boxIfRequired(VariableElement element) {
        String format = PRIMITIVE_TO_BOXED.get(element.asType().getKind());
        if (format == null) {
            return element.getSimpleName().toString();
        }
        return String.format(format, element.getSimpleName().toString());
    }

    /**
     * The super method must include the return type, otherwise its ambiguous
     * for methods with covariant return types.
     */
    private String superMethodName(ExecutableElement method) {
        return "super$" + method.getSimpleName().toString() + "$" + typeToString(method.getReturnType()).replace('.', '_').replace('[', '_').replace(';', '_');
    }

    private String typeToString(TypeMirror typeMirror) {
        if (typeMirror.getKind().isPrimitive() || typeMirror.getKind() == TypeKind.VOID) {
            return typeMirror.toString();
        } else {
            StringBuilder rawType = new StringBuilder();
            rawTypeToString(rawType, (TypeElement) mTypes.asElement(typeMirror), '$');
            return rawType.toString();
        }
    }

    static void rawTypeToString(StringBuilder result, TypeElement type,
                                char innerClassSeparator) {
        String packageName = getPackage(type).getQualifiedName().toString();
        String qualifiedName = type.getQualifiedName().toString();
        if (packageName.isEmpty()) {
            result.append(qualifiedName.replace('.', innerClassSeparator));
        } else {
            result.append(packageName);
            result.append('.');
            result.append(
                    qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
        }
    }

    public static PackageElement getPackage(Element type) {
        while (type.getKind() != ElementKind.PACKAGE) {
            type = type.getEnclosingElement();
        }
        return (PackageElement) type;
    }

    private void  generateConstructorsAndFields() {
        FieldSpec handler = FieldSpec.builder(InvocationHandler.class, FIELD_NAME_HANDLER)
                .addModifiers(Modifier.PRIVATE)
                .build();
        mProxyClass.addField(handler);

        FieldSpec methodArray = FieldSpec.builder(Method[].class, FIELD_NAME_METHODS)
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
                .build();
        mProxyClass.addField(methodArray);

        for (Element element : mElements.getAllMembers(mBaseClass)) {
            if (element.getKind().equals(ElementKind.CONSTRUCTOR) && !element.getModifiers().contains(Modifier.FINAL)) {
                ExecutableElement constructorElement = (ExecutableElement) element;
                MethodSpec.Builder constructorMethod = MethodSpec.constructorBuilder();
                constructorMethod.addModifiers(Modifier.PUBLIC);
                List<? extends VariableElement> paramters = constructorElement.getParameters();
                if (paramters!=null && paramters.size()>0) {
                    for (VariableElement e : paramters) {
                        constructorMethod.addParameter(convertToTypeName(e.getEnclosingElement().asType()), e.getSimpleName().toString());
                    }
                }
                mProxyClass.addMethod(constructorMethod.build());
            }
        }
    }

    private ExecutableElement[] getMethodsToProxyRecursive() {
        Set<MethodSetEntry> methodsToProxy = new HashSet<>();
        Set<MethodSetEntry> seenFinalMethods = new HashSet<>();

        for (TypeElement c = mBaseClass; (!(c instanceof NoType) && c != null); c = (TypeElement) mTypes.asElement(c.getSuperclass())) {
            getMethodsToProxy(methodsToProxy, seenFinalMethods, c);
        }

        for (TypeElement c = mBaseClass; (!(c instanceof NoType) && c != null); c = (TypeElement) mTypes.asElement(c.getSuperclass())) {
            for (TypeMirror i : c.getInterfaces()) {
                getMethodsToProxy(methodsToProxy, seenFinalMethods, (TypeElement) mTypes.asElement(i));
            }
        }

        MethodSetEntry[] methodSetEntryArr = new MethodSetEntry[methodsToProxy.size()];
        int i=0;
        for (MethodSetEntry methodSetEntry:methodsToProxy) {
            methodSetEntryArr[i] = methodSetEntry;
            i++;
        }
        Arrays.sort(methodSetEntryArr);
        ExecutableElement[] methodArr = new ExecutableElement[methodsToProxy.size()];
        i=0;
        while (i < methodSetEntryArr.length) {
            methodArr[i] = methodSetEntryArr[i].originalMethod;
            i++;
        }
        return methodArr;
    }

    private void getMethodsToProxy(Set<MethodSetEntry> sink, Set<MethodSetEntry> seenFinalMethods,
                                   TypeElement c) {
        List<ExecutableElement> declarMethods = ElementFilter.methodsIn(mElements.getAllMembers(c));
        if (declarMethods == null || declarMethods.size()==0) {
            return;
        }
        for (ExecutableElement method : declarMethods) {
            if ((method.getModifiers().contains(Modifier.FINAL))) {
                // Skip final methods, we can't override them. We
                // also need to remember them, in case the same
                // method exists in a parent class.
                MethodSetEntry entry = new MethodSetEntry(method);
                seenFinalMethods.add(entry);
                // We may have seen this method already, from an interface
                // implemented by a child class. We need to remove it here.
                sink.remove(entry);
                continue;
            }

            // Skip static methods, overriding them has no effect.

            // Skip private methods, since they are invoked through direct
            // invocation (as opposed to virtual). Therefore, it would not
            // be possible to intercept any private method defined inside
            // the proxy class except through reflection.

            // Skip package-private methods as well (for non-shared class
            // loaders). The proxy class does
            // not actually inherit package-private methods from the parent
            // class because it is not a member of the parent's package.
            // This is even true if the two classes have the same package
            // name, as they use different class loaders.

            // Skip finalize method, it's likely important that it execute as normal.

            if (!method.getModifiers().contains(Modifier.STATIC)
                    && (method.getModifiers().contains(Modifier.PUBLIC) || method.getModifiers().contains(Modifier.PROTECTED))
                    && !((method.getSimpleName().toString().equals("finalize") && method.getParameters().size() == 0))) {

                MethodSetEntry methodSetEntry;
                methodSetEntry = new MethodSetEntry(method);
                if (!(seenFinalMethods.contains(methodSetEntry) || sink.contains(methodSetEntry))) {
                    sink.add(methodSetEntry);
                }
                continue;
            }

        }
    }

}
